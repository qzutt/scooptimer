<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5g Simulation | The Heroic Dose</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; }
        .interactive { pointer-events: auto; }
        
        /* CRT Scanline effect for realism */
        .scanlines {
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px;
            position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; z-index: 5; opacity: 0.3;
        }

        /* Vignette */
        .vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, black 100%);
            z-index: 4; pointer-events: none; opacity: 0.6;
        }

        .thought-bubble {
            position: absolute;
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.2rem;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            opacity: 0;
            transition: opacity 2s ease-in-out;
            pointer-events: none;
            width: 300px;
            text-align: center;
        }

        /* Range Slider */
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #fff; cursor: pointer; margin-top: -6px; box-shadow: 0 0 10px #fff;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: rgba(255,255,255,0.3); border-radius: 2px;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div class="scanlines"></div>
    <div class="vignette"></div>

    <div id="ui-layer">
        <!-- Header -->
        <div class="flex justify-between items-start">
            <div>
                <h1 class="text-2xl font-bold tracking-widest uppercase">Subject: #0492</h1>
                <p class="text-xs text-gray-400">Dosage: 5.0g Dried Psilocybe Cubensis</p>
                <p class="text-xs text-gray-400">Method: Lemon Tek</p>
                <div id="status-text" class="mt-4 text-yellow-400 font-bold text-lg animate-pulse">STATUS: SOBRIETY</div>
            </div>
            <div class="text-right">
                <div id="timer" class="text-3xl font-mono">T-00:00:00</div>
                <div id="bpm" class="text-sm text-red-400">HR: 72 BPM</div>
            </div>
        </div>

        <!-- Center Warning/Start -->
        <div id="start-screen" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center interactive">
            <p class="mb-4 max-w-md text-sm text-gray-300">
                WARNING: This simulation utilizes strobing lights, binaural audio, and intense visual distortion. 
                It approximates the dissolution of the ego and high-level geometric hallucination.
            </p>
            <button id="start-btn" class="border border-white px-8 py-3 hover:bg-white hover:text-black transition duration-300 uppercase tracking-widest font-bold">
                Ingest Capsule
            </button>
        </div>

        <!-- Footer Controls -->
        <div class="w-full max-w-2xl mx-auto mb-8 interactive opacity-0 transition-opacity duration-1000" id="controls">
            <div class="flex justify-between text-xs text-gray-400 mb-2">
                <span>ONSET</span>
                <span>PEAK</span>
                <span>DISSOLUTION</span>
                <span>COMEDOWN</span>
            </div>
            <input type="range" min="0" max="100" value="0" id="trip-slider">
            <p class="text-center text-xs text-gray-500 mt-2">Drag to scrub timeline (Simulation Mode)</p>
        </div>
    </div>

    <!-- Audio Warning Overlay (Hidden by default) -->
    <div id="thought-container"></div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            colors: {
                base: new THREE.Color(0x000000),
                peak: new THREE.Color(0xff00ff),
            },
            thoughts: [
                "Why is the room breathing?",
                "My hands look... ancient.",
                "The geometry is the language of the walls.",
                "There is no 'I' anymore.",
                "Just frequency. Just vibration.",
                "I am the universe observing itself.",
                "Time has stopped.",
                "It's all love.",
                "The grid is visible.",
                "Remember to breathe."
            ]
        };

        // --- STATE MANAGEMENT ---
        let state = {
            intensity: 0, // 0.0 to 1.0
            phase: 'sober', // sober, onset, peak, dissolution, comedown
            isPlaying: false,
            time: 0
        };

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- AUDIO SYSTEM (Web Audio API) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let oscillators = [];
        let gainNodes = [];
        let masterGain;

        function initAudio() {
            audioCtx = new AudioContext();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.1; // Start quiet
            masterGain.connect(audioCtx.destination);

            // Drone 1 (Low Theta)
            createOscillator(55, 'sine', 0.5); 
            // Drone 2 (Binaural offset)
            createOscillator(59, 'sine', 0.5);
            // High ringing (The "Carrier Wave")
            createOscillator(800, 'triangle', 0.0); // Volume controlled by intensity
        }

        function createOscillator(freq, type, vol) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.value = vol;
            osc.connect(gain);
            gain.connect(masterGain);
            osc.start();
            oscillators.push(osc);
            gainNodes.push(gain);
        }

        function updateAudio(intensity) {
            if (!audioCtx) return;
            
            // Pitch bending based on intensity (The "Warping" sound)
            const wobble = Math.sin(Date.now() * 0.001) * (intensity * 10);
            
            if (oscillators[0]) oscillators[0].frequency.setTargetAtTime(55 + wobble, audioCtx.currentTime, 0.1);
            if (oscillators[1]) oscillators[1].frequency.setTargetAtTime(59 - wobble, audioCtx.currentTime, 0.1);
            
            // Introduce the high carrier ring at peak
            if (gainNodes[2]) {
                gainNodes[2].gain.setTargetAtTime(intensity * 0.15, audioCtx.currentTime, 0.5);
            }

            // Master volume swell
            masterGain.gain.setTargetAtTime(0.1 + (intensity * 0.3), audioCtx.currentTime, 0.1);
        }


        // --- GEOMETRY & SHADERS ---

        // 1. The Tunnel (Wireframe Structure)
        const tunnelGeo = new THREE.TorusKnotGeometry(10, 3, 100, 16);
        const tunnelMat = new THREE.MeshBasicMaterial({ 
            color: 0x444444, 
            wireframe: true, 
            transparent: true, 
            opacity: 0.1 
        });
        const tunnel = new THREE.Mesh(tunnelGeo, tunnelMat);
        scene.add(tunnel);

        // 2. The "Fractal" Wall (Custom Shader)
        // This shader simulates the breathing, color-shifting patterns seen on surfaces
        const vertexShader = `
            varying vec2 vUv;
            varying vec3 vPos;
            uniform float uTime;
            uniform float uIntensity;

            void main() {
                vUv = uv;
                vPos = position;
                
                // BREATHING EFFECT
                vec3 pos = position;
                float breath = sin(uTime * 0.5) * uIntensity * 2.0;
                pos += normal * breath;

                // WARPING
                float warp = sin(pos.y * 5.0 + uTime) * uIntensity * 0.5;
                pos.x += warp;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const fragmentShader = `
            varying vec2 vUv;
            varying vec3 vPos;
            uniform float uTime;
            uniform float uIntensity;

            // Palette function for trippy colors (Cosine based)
            vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {
                return a + b*cos( 6.28318*(c*t+d) );
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 uv0 = uv;
                
                // Fractalize UVs
                float dist = length(uv);
                
                // Tunnel vision effect at high intensity
                uv *= 1.0 - (uIntensity * 0.5 * dist);

                vec3 finalColor = vec3(0.0);

                for (float i = 0.0; i < 3.0; i++) {
                    uv = fract(uv * 1.5) - 0.5;

                    float d = length(uv) * exp(-length(uv0));

                    vec3 col = palette(length(uv0) + i*.4 + uTime*.4, 
                      vec3(0.5, 0.5, 0.5),
                      vec3(0.5, 0.5, 0.5),
                      vec3(1.0, 1.0, 1.0),
                      vec3(0.263,0.416,0.557)
                    );

                    d = sin(d*8. + uTime)/8.;
                    d = abs(d);
                    
                    // Sharpness decreases as ego dissolves
                    d = pow(0.01 / d, 1.2);

                    finalColor += col * d;
                }

                // Mix with black based on intensity (Onset is dark, Peak is bright)
                float visibility = smoothstep(0.0, 0.2, uIntensity); 
                
                gl_FragColor = vec4(finalColor * visibility, 1.0);
            }
        `;

        const fractalMaterial = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uIntensity: { value: 0 }
            },
            side: THREE.DoubleSide,
            transparent: true
        });

        const sphereGeo = new THREE.IcosahedronGeometry(6, 4);
        const fractalSphere = new THREE.Mesh(sphereGeo, fractalMaterial);
        scene.add(fractalSphere);

        // 3. Floating Particles (Tracers)
        const particlesGeo = new THREE.BufferGeometry();
        const count = 2000;
        const positions = new Float32Array(count * 3);
        for(let i=0; i<count*3; i++) {
            positions[i] = (Math.random() - 0.5) * 20;
        }
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const particlesMat = new THREE.PointsMaterial({ size: 0.05, color: 0xffffff });
        const particles = new THREE.Points(particlesGeo, particlesMat);
        scene.add(particles);


        // --- INTERACTIVITY ---
        const slider = document.getElementById('trip-slider');
        const startBtn = document.getElementById('start-btn');
        const controlsDiv = document.getElementById('controls');
        const statusText = document.getElementById('status-text');
        const timerText = document.getElementById('timer');
        const bpmText = document.getElementById('bpm');

        let mouseX = 0, mouseY = 0;
        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX - window.innerWidth / 2) * 0.001;
            mouseY = (e.clientY - window.innerHeight / 2) * 0.001;
        });

        startBtn.addEventListener('click', () => {
            state.isPlaying = true;
            document.getElementById('start-screen').style.display = 'none';
            controlsDiv.style.opacity = '1';
            initAudio();
            
            // Start automatic progression simulation
            let progress = 0;
            const interval = setInterval(() => {
                if(!state.isPlaying) return;
                // Only auto-progress if user isn't scrubbing (simple logic: just update slider)
                // For this demo, let's trust the user to scrub, but start them at 0
            }, 1000);
        });

        slider.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            state.intensity = val / 100;
            updatePhase(val);
        });

        function updatePhase(val) {
            if (val < 10) {
                state.phase = 'Onset';
                statusText.innerText = "STATUS: ONSET (Anxiety/Alertness)";
                statusText.className = "mt-4 text-blue-400 font-bold text-lg animate-pulse";
            } else if (val < 40) {
                state.phase = 'Rising';
                statusText.innerText = "STATUS: VISUAL DISTORTION";
                statusText.className = "mt-4 text-green-400 font-bold text-lg";
            } else if (val < 70) {
                state.phase = 'Peak';
                statusText.innerText = "STATUS: PEAK (Geometry/Ego Loss)";
                statusText.className = "mt-4 text-purple-500 font-bold text-lg animate-pulse";
            } else if (val < 90) {
                state.phase = 'Dissolution';
                statusText.innerText = "STATUS: THE VOID";
                statusText.className = "mt-4 text-white font-bold text-lg";
            } else {
                state.phase = 'Comedown';
                statusText.innerText = "STATUS: AFTERGLOW";
                statusText.className = "mt-4 text-orange-300 font-bold text-lg";
            }

            // Update simulated timer based on slider
            const hours = Math.floor((val / 100) * 6);
            const mins = Math.floor(((val / 100) * 6 % 1) * 60);
            timerText.innerText = `T+0${hours}:${mins < 10 ? '0'+mins : mins}:00`;
            
            // Update Heart Rate simulation
            let bpm = 70;
            if (val > 10 && val < 80) bpm = 90 + Math.random() * 20;
            bpmText.innerText = `HR: ${Math.floor(bpm)} BPM`;
        }

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();
        let thoughtTimer = 0;

        function spawnThought() {
            const container = document.getElementById('thought-container');
            const text = CONFIG.thoughts[Math.floor(Math.random() * CONFIG.thoughts.length)];
            const el = document.createElement('div');
            el.className = 'thought-bubble';
            el.innerText = text;
            
            // Random position
            const x = Math.random() * 80 + 10;
            const y = Math.random() * 80 + 10;
            el.style.left = x + '%';
            el.style.top = y + '%';
            
            container.appendChild(el);

            // Animation sequence
            setTimeout(() => { el.style.opacity = Math.min(state.intensity + 0.2, 1); }, 100);
            setTimeout(() => { el.style.opacity = 0; }, 3000);
            setTimeout(() => { el.remove(); }, 5000);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            
            // Update Uniforms
            fractalMaterial.uniforms.uTime.value = time;
            fractalMaterial.uniforms.uIntensity.value = state.intensity;

            // Camera Movement (Drifting)
            // Sobriety = steady. High dose = floaty/detached.
            const driftSpeed = 0.1 + (state.intensity * 0.5);
            camera.position.x += (mouseX - camera.position.x) * (0.01 * (1-state.intensity)); // Mouse control fades at high dose
            camera.position.y += (mouseY - camera.position.y) * (0.01 * (1-state.intensity));
            
            // Auto rotation/tumbling at peak
            if (state.intensity > 0.6) {
                camera.rotation.z += 0.001 * (state.intensity * 5);
                tunnel.rotation.z -= 0.005;
            }
            
            // Tunnel Breathing
            tunnel.scale.setScalar(1 + Math.sin(time) * (state.intensity * 0.2));
            tunnel.rotation.x += 0.001;
            tunnel.rotation.y += 0.002;
            
            // Color shifting the tunnel wireframe
            const hue = (time * 0.1) % 1;
            tunnelMat.color.setHSL(hue, 0.5, 0.5);
            tunnelMat.opacity = 0.1 + (state.intensity * 0.4);

            // Particle warp
            const positions = particles.geometry.attributes.position.array;
            for(let i = 0; i < count * 3; i+=3) {
                // Wobbly particles
                positions[i+1] += Math.sin(time + positions[i]) * 0.01 * state.intensity;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // FOV Distortion (The "Zoom" feeling)
            const targetFOV = 75 + (state.intensity * 40); // Wide FOV at peak
            camera.fov += (targetFOV - camera.fov) * 0.05;
            camera.updateProjectionMatrix();

            // Audio updates
            updateAudio(state.intensity);

            // Thoughts
            if (state.intensity > 0.2) {
                thoughtTimer += 1;
                // More thoughts at higher intensity, but chaotic
                const threshold = 300 - (state.intensity * 200); 
                if (thoughtTimer > threshold) {
                    spawnThought();
                    thoughtTimer = 0;
                }
            }

            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
